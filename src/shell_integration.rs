use anyhow::{anyhow, Result};
use chrono::Utc;
use dirs;
use inquire::{Confirm, Select};
use std::path::{Path, PathBuf};
use tokio::fs;

#[derive(Debug, Clone)]
enum ConflictAction {
    Backup,
    Remove,
    Cancel,
}

/// Detects if the current shell is Fish
pub fn is_fish_shell() -> bool {
    std::env::var("FISH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/fish"))
            .unwrap_or(false)
}

/// Detects if the current shell is Zsh
pub fn is_zsh_shell() -> bool {
    std::env::var("ZSH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/zsh"))
            .unwrap_or(false)
}

/// Detects if the current shell is Bash
pub fn is_bash_shell() -> bool {
    std::env::var("BASH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/bash"))
            .unwrap_or(false)
}

/// Check if Fish function file exists
fn fish_function_exists() -> bool {
    let fish_functions_dir = dirs::home_dir()
        .map(|home| home.join(".config/fish/functions"))
        .unwrap_or_default();
    fish_functions_dir.join("pm.fish").exists()
}

/// Handle conflict when existing Fish function is found
async fn handle_fish_function_conflict(existing_path: &Path) -> Result<ConflictAction> {
    println!("‚ö†Ô∏è  Found existing Fish function: {}", existing_path.display());

    let existing_content = fs::read_to_string(existing_path).await?;
    let is_pm_generated = existing_content.contains("# Generated by PM v");

    if is_pm_generated {
        println!("üîÑ Existing file was generated by PM - will update automatically");
        return Ok(ConflictAction::Remove);
    }

    // Show preview of existing function (first 5 lines)
    let preview_lines: Vec<&str> = existing_content.lines().take(5).collect();
    println!("\nüìã Current function preview:");
    for (i, line) in preview_lines.iter().enumerate() {
        println!("   {}: {}", i + 1, line);
    }
    if existing_content.lines().count() > 5 {
        println!(
            "   ... ({} more lines)",
            existing_content.lines().count() - 5
        );
    }

    let options = vec![
        "Backup existing and install PM integration",
        "Remove existing and install PM integration",
        "Cancel installation",
    ];

    let selection = Select::new("How would you like to proceed?", options)
        .with_help_message("Choose how to handle the existing pm.fish function")
        .prompt()?;

    match selection {
        "Backup existing and install PM integration" => Ok(ConflictAction::Backup),
        "Remove existing and install PM integration" => Ok(ConflictAction::Remove),
        "Cancel installation" => Ok(ConflictAction::Cancel),
        _ => unreachable!(),
    }
}

/// Create backup of existing function file
async fn backup_existing_function(original_path: &Path) -> Result<PathBuf> {
    let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
    let backup_path = original_path.with_file_name(format!("pm.fish.backup.{}", timestamp));

    // Handle case where backup filename already exists
    let mut counter = 1;
    let mut final_backup_path = backup_path.clone();
    while final_backup_path.exists() {
        final_backup_path = original_path
            .with_file_name(format!("pm.fish.backup.{}.{}", timestamp, counter));
        counter += 1;
    }

    fs::copy(original_path, &final_backup_path).await?;
    println!("üíæ Backed up to: {}", final_backup_path.display());

    Ok(final_backup_path)
}

/// Generate Fish function content
fn create_fish_function_content() -> String {
    format!(
        r#"# Generated by PM v{} - Fish shell integration
# This function enables directory switching with 'pm sw'
# 
# To remove this integration:
#   rm ~/.config/fish/functions/pm.fish
#
# To disable temporarily:
#   functions -e pm

function pm
    if test "$argv[1]" = "sw" -o "$argv[1]" = "switch"
        set pm_output (command pm $argv 2>&1)
        set pm_status $status
        
        if test $pm_status -eq 0
            # Extract directory from PM output
            set new_dir (echo $pm_output | grep "Switched to:" | sed 's/.*Switched to: //')
            if test -n "$new_dir" -a -d "$new_dir"
                cd "$new_dir"
                echo "üìÅ Changed directory to: $new_dir"
            else
                echo $pm_output
            end
        else
            echo $pm_output
        end
        
        return $pm_status
    else
        command pm $argv
    end
end"#,
        env!("CARGO_PKG_VERSION")
    )
}

/// Setup Fish shell integration
async fn setup_fish_integration() -> Result<()> {
    let fish_functions_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/fish/functions");

    let pm_fish_path = fish_functions_dir.join("pm.fish");

    // Handle existing file conflict
    if pm_fish_path.exists() {
        match handle_fish_function_conflict(&pm_fish_path).await? {
            ConflictAction::Backup => {
                let backup_path = backup_existing_function(&pm_fish_path).await?;
                println!(
                    "üí° To restore: mv {} {}",
                    backup_path.display(),
                    pm_fish_path.display()
                );
            }
            ConflictAction::Remove => {
                fs::remove_file(&pm_fish_path).await?;
                println!("üóëÔ∏è  Removed existing pm.fish function");
            }
            ConflictAction::Cancel => {
                println!("‚ùå Fish integration setup cancelled");
                println!("üí° You can manually add PM integration to your existing function");
                return Ok(());
            }
        }
    }

    // Create directory and write new function file
    fs::create_dir_all(&fish_functions_dir).await?;

    let pm_fish_content = create_fish_function_content();
    fs::write(&pm_fish_path, pm_fish_content).await?;

    println!("üê† Fish shell integration installed successfully");
    println!("   Function file: {}", pm_fish_path.display());
    println!("   Usage: pm sw <project> will now change your shell directory");

    Ok(())
}

/// Setup shell integration based on detected shell
pub async fn setup_shell_integration() -> Result<()> {
    if is_fish_shell() {
        if !fish_function_exists() {
            setup_fish_integration().await?;
        } else {
            println!("üê† Fish shell integration already exists");
        }
    } else if is_zsh_shell() || is_bash_shell() {
        println!("üöß Bash/Zsh integration coming soon!");
        println!("üí° For now, you can manually add this to your shell config:");
        println!("   pm() {{ if [[ \"$1\" == \"sw\" ]]; then eval \"$(command pm \"$@\")\"; else command pm \"$@\"; fi; }}");
    } else {
        println!("‚ùì Unknown shell detected");
        println!("üí° Current shell: {}", std::env::var("SHELL").unwrap_or_default());
    }

    Ok(())
}

/// Check if shell integration should be automatically set up
pub async fn check_and_setup_shell_integration() -> Result<()> {
    if is_fish_shell() && !fish_function_exists() {
        let should_setup = Confirm::new("Setup Fish shell integration for directory switching?")
            .with_default(true)
            .with_help_message("This will allow 'pm sw' to change your shell's current directory")
            .prompt()?;

        if should_setup {
            setup_fish_integration().await?;
        }
    }

    Ok(())
}