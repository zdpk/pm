use anyhow::{anyhow, Result};
use chrono::Utc;
use dirs;
use inquire::{Confirm, Select};
use std::path::{Path, PathBuf};
use tokio::fs;

#[derive(Debug, Clone)]
enum ConflictAction {
    Backup,
    Remove,
    Cancel,
}

#[derive(Debug, Clone)]
pub enum ShellType {
    Fish,
    Zsh,
    Bash,
    Unknown,
}

/// Detects the current shell type
pub fn detect_shell() -> ShellType {
    if std::env::var("FISH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/fish"))
            .unwrap_or(false)
    {
        ShellType::Fish
    } else if std::env::var("ZSH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/zsh"))
            .unwrap_or(false)
    {
        ShellType::Zsh
    } else if std::env::var("BASH_VERSION").is_ok()
        || std::env::var("SHELL")
            .map(|s| s.ends_with("/bash"))
            .unwrap_or(false)
    {
        ShellType::Bash
    } else {
        ShellType::Unknown
    }
}

/// Legacy helper functions for backward compatibility
pub fn is_fish_shell() -> bool {
    matches!(detect_shell(), ShellType::Fish)
}

pub fn is_zsh_shell() -> bool {
    matches!(detect_shell(), ShellType::Zsh)
}

pub fn is_bash_shell() -> bool {
    matches!(detect_shell(), ShellType::Bash)
}

/// Check if shell integration exists for the given shell type
pub fn shell_integration_exists(shell_type: &ShellType) -> bool {
    match shell_type {
        ShellType::Fish => fish_function_exists(),
        ShellType::Zsh => zsh_integration_exists(),
        ShellType::Bash => bash_integration_exists(),
        ShellType::Unknown => false,
    }
}

/// Check if Fish function file exists
fn fish_function_exists() -> bool {
    let fish_functions_dir = dirs::home_dir()
        .map(|home| home.join(".config/fish/functions"))
        .unwrap_or_default();
    fish_functions_dir.join("pm.fish").exists()
}

/// Check if Zsh integration exists
fn zsh_integration_exists() -> bool {
    let config_dir = dirs::home_dir()
        .map(|home| home.join(".config/pm"))
        .unwrap_or_default();
    let zsh_file = config_dir.join("pm.zsh");
    
    if !zsh_file.exists() {
        return false;
    }
    
    // Check if .zshrc sources the file
    let zshrc_path = dirs::home_dir()
        .map(|home| home.join(".zshrc"))
        .unwrap_or_default();
    
    if let Ok(content) = std::fs::read_to_string(zshrc_path) {
        content.contains("source ~/.config/pm/pm.zsh") || content.contains(". ~/.config/pm/pm.zsh")
    } else {
        false
    }
}

/// Check if Bash integration exists
fn bash_integration_exists() -> bool {
    let config_dir = dirs::home_dir()
        .map(|home| home.join(".config/pm"))
        .unwrap_or_default();
    let bash_file = config_dir.join("pm.bash");
    
    if !bash_file.exists() {
        return false;
    }
    
    // Check if .bashrc sources the file
    let bashrc_path = dirs::home_dir()
        .map(|home| home.join(".bashrc"))
        .unwrap_or_default();
    
    if let Ok(content) = std::fs::read_to_string(bashrc_path) {
        content.contains("source ~/.config/pm/pm.bash") || content.contains(". ~/.config/pm/pm.bash")
    } else {
        false
    }
}

/// Handle conflict when existing Fish function is found
async fn handle_fish_function_conflict(existing_path: &Path) -> Result<ConflictAction> {
    println!("⚠️  Found existing Fish function: {}", existing_path.display());

    let existing_content = fs::read_to_string(existing_path).await?;
    let is_pm_generated = existing_content.contains("# Generated by PM v");

    if is_pm_generated {
        println!("🔄 Existing file was generated by PM - will update automatically");
        return Ok(ConflictAction::Remove);
    }

    // Show preview of existing function (first 5 lines)
    let preview_lines: Vec<&str> = existing_content.lines().take(5).collect();
    println!("\n📋 Current function preview:");
    for (i, line) in preview_lines.iter().enumerate() {
        println!("   {}: {}", i + 1, line);
    }
    if existing_content.lines().count() > 5 {
        println!(
            "   ... ({} more lines)",
            existing_content.lines().count() - 5
        );
    }

    let options = vec![
        "Backup existing and install PM integration",
        "Remove existing and install PM integration",
        "Cancel installation",
    ];

    let selection = Select::new("How would you like to proceed?", options)
        .with_help_message("Choose how to handle the existing pm.fish function")
        .prompt()?;

    match selection {
        "Backup existing and install PM integration" => Ok(ConflictAction::Backup),
        "Remove existing and install PM integration" => Ok(ConflictAction::Remove),
        "Cancel installation" => Ok(ConflictAction::Cancel),
        _ => unreachable!(),
    }
}

/// Create backup of existing function file
async fn backup_existing_function(original_path: &Path) -> Result<PathBuf> {
    let timestamp = Utc::now().format("%Y%m%d_%H%M%S");
    let backup_path = original_path.with_file_name(format!("pm.fish.backup.{}", timestamp));

    // Handle case where backup filename already exists
    let mut counter = 1;
    let mut final_backup_path = backup_path.clone();
    while final_backup_path.exists() {
        final_backup_path = original_path
            .with_file_name(format!("pm.fish.backup.{}.{}", timestamp, counter));
        counter += 1;
    }

    fs::copy(original_path, &final_backup_path).await?;
    println!("💾 Backed up to: {}", final_backup_path.display());

    Ok(final_backup_path)
}

/// Generate Fish function content
fn create_fish_function_content() -> String {
    format!(
        r#"# Generated by PM v{} - Fish shell integration
# This function enables directory switching with 'pm sw'
# 
# To remove this integration:
#   rm ~/.config/fish/functions/pm.fish
#
# To disable temporarily:
#   functions -e pm

function pm
    if test "$argv[1]" = "sw" -o "$argv[1]" = "switch"
        set pm_output (command pm $argv 2>&1)
        set pm_status $status
        
        if test $pm_status -eq 0
            # Extract directory from PM output
            set new_dir (echo $pm_output | grep "Switched to:" | sed 's/.*Switched to: //')
            if test -n "$new_dir" -a -d "$new_dir"
                cd "$new_dir"
                echo "📁 Changed directory to: $new_dir"
            else
                echo $pm_output
            end
        else
            echo $pm_output
        end
        
        return $pm_status
    else
        command pm $argv
    end
end"#,
        env!("CARGO_PKG_VERSION")
    )
}

/// Setup Fish shell integration
async fn setup_fish_integration() -> Result<()> {
    let fish_functions_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/fish/functions");

    let pm_fish_path = fish_functions_dir.join("pm.fish");

    // Handle existing file conflict
    if pm_fish_path.exists() {
        match handle_fish_function_conflict(&pm_fish_path).await? {
            ConflictAction::Backup => {
                let backup_path = backup_existing_function(&pm_fish_path).await?;
                println!(
                    "💡 To restore: mv {} {}",
                    backup_path.display(),
                    pm_fish_path.display()
                );
            }
            ConflictAction::Remove => {
                fs::remove_file(&pm_fish_path).await?;
                println!("🗑️  Removed existing pm.fish function");
            }
            ConflictAction::Cancel => {
                println!("❌ Fish integration setup cancelled");
                println!("💡 You can manually add PM integration to your existing function");
                return Ok(());
            }
        }
    }

    // Create directory and write new function file
    fs::create_dir_all(&fish_functions_dir).await?;

    let pm_fish_content = create_fish_function_content();
    fs::write(&pm_fish_path, pm_fish_content).await?;

    println!("🐠 Fish shell integration installed successfully");
    println!("   Function file: {}", pm_fish_path.display());
    println!("   Usage: pm sw <project> will now change your shell directory");

    Ok(())
}

/// Setup shell integration for init command
pub async fn setup_shell_integration_for_init() -> Result<()> {
    let shell_type = detect_shell();
    
    match shell_type {
        ShellType::Unknown => {
            println!("❓ Unknown shell detected");
            println!("💡 Current shell: {}", std::env::var("SHELL").unwrap_or_default());
            println!("💡 Manual setup may be required");
            return Ok(());
        }
        _ => {}
    }
    
    let shell_name = match shell_type {
        ShellType::Fish => "Fish",
        ShellType::Zsh => "Zsh", 
        ShellType::Bash => "Bash",
        ShellType::Unknown => "Unknown",
    };
    
    // Check if integration already exists
    if shell_integration_exists(&shell_type) {
        println!("🔧 {} shell integration already exists", shell_name);
        return Ok(());
    }
    
    let should_setup = Confirm::new(&format!("Setup {} shell integration for directory switching?", shell_name))
        .with_default(true)
        .with_help_message("This will allow 'pm sw' to change your shell's current directory")
        .prompt()?;

    if !should_setup {
        println!("⏭️  Skipped shell integration setup");
        println!("💡 You can manually setup later or run 'pm init' again");
        return Ok(());
    }

    match shell_type {
        ShellType::Fish => setup_fish_integration().await?,
        ShellType::Zsh => setup_zsh_integration().await?,
        ShellType::Bash => setup_bash_integration().await?,
        ShellType::Unknown => unreachable!(),
    }

    Ok(())
}

/// Create Zsh function content
fn create_zsh_function_content() -> String {
    format!(
        r#"# Generated by PM v{} - Zsh shell integration
# This function enables directory switching with 'pm sw'

pm() {{
    if [[ "$1" == "sw" || "$1" == "switch" ]]; then
        local pm_output
        pm_output=$(command pm "$@" 2>&1)
        local pm_status=$?
        
        if [[ $pm_status -eq 0 ]]; then
            # Extract directory from PM output
            local new_dir
            new_dir=$(echo "$pm_output" | grep "Switched to:" | sed 's/.*Switched to: //')
            if [[ -n "$new_dir" && -d "$new_dir" ]]; then
                cd "$new_dir"
                echo "📁 Changed directory to: $new_dir"
            else
                echo "$pm_output"
            fi
        else
            echo "$pm_output"
        fi
        
        return $pm_status
    else
        command pm "$@"
    fi
}}"#,
        env!("CARGO_PKG_VERSION")
    )
}

/// Create Bash function content
fn create_bash_function_content() -> String {
    format!(
        r#"# Generated by PM v{} - Bash shell integration
# This function enables directory switching with 'pm sw'

pm() {{
    if [[ "$1" == "sw" || "$1" == "switch" ]]; then
        local pm_output
        pm_output=$(command pm "$@" 2>&1)
        local pm_status=$?
        
        if [[ $pm_status -eq 0 ]]; then
            # Extract directory from PM output
            local new_dir
            new_dir=$(echo "$pm_output" | grep "Switched to:" | sed 's/.*Switched to: //')
            if [[ -n "$new_dir" && -d "$new_dir" ]]; then
                cd "$new_dir"
                echo "📁 Changed directory to: $new_dir"
            else
                echo "$pm_output"
            fi
        else
            echo "$pm_output"
        fi
        
        return $pm_status
    else
        command pm "$@"
    fi
}}"#,
        env!("CARGO_PKG_VERSION")
    )
}

/// Setup Zsh shell integration
async fn setup_zsh_integration() -> Result<()> {
    let config_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/pm");
    
    let zsh_file_path = config_dir.join("pm.zsh");
    let zshrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".zshrc");
    
    // Create config directory if it doesn't exist
    fs::create_dir_all(&config_dir).await?;
    
    // Handle existing pm.zsh file conflict
    if zsh_file_path.exists() {
        let existing_content = fs::read_to_string(&zsh_file_path).await?;
        if !existing_content.contains("# Generated by PM v") {
            // User-created file, ask for confirmation
            let should_overwrite = Confirm::new("Existing pm.zsh file found. Overwrite?")
                .with_default(false)
                .prompt()?;
            
            if !should_overwrite {
                println!("❌ Zsh integration setup cancelled");
                return Ok(());
            }
            
            // Backup existing file
            let backup_path = zsh_file_path.with_extension("zsh.backup");
            fs::copy(&zsh_file_path, &backup_path).await?;
            println!("💾 Backed up existing file to: {}", backup_path.display());
        }
    }
    
    // Create the Zsh function file
    let zsh_content = create_zsh_function_content();
    fs::write(&zsh_file_path, zsh_content).await?;
    
    // Add source line to .zshrc if it doesn't exist
    let source_line = "source ~/.config/pm/pm.zsh";
    let mut needs_source_line = true;
    
    if zshrc_path.exists() {
        let zshrc_content = fs::read_to_string(&zshrc_path).await?;
        if zshrc_content.contains(source_line) || zshrc_content.contains(". ~/.config/pm/pm.zsh") {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM (Project Manager) shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if zshrc_path.exists() {
            // Append to existing .zshrc
            let mut existing_content = fs::read_to_string(&zshrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&zshrc_path, existing_content).await?;
        } else {
            // Create new .zshrc
            fs::write(&zshrc_path, source_content).await?;
        }
        
        println!("📝 Added source line to .zshrc");
    }
    
    println!("🐚 Zsh shell integration installed successfully");
    println!("   Function file: {}", zsh_file_path.display());
    println!("   Sourced from: {}", zshrc_path.display());
    println!("   Usage: pm sw <project> will now change your shell directory");
    
    Ok(())
}

/// Setup Bash shell integration
async fn setup_bash_integration() -> Result<()> {
    let config_dir = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".config/pm");
    
    let bash_file_path = config_dir.join("pm.bash");
    let bashrc_path = dirs::home_dir()
        .ok_or_else(|| anyhow!("Could not find home directory"))?
        .join(".bashrc");
    
    // Create config directory if it doesn't exist
    fs::create_dir_all(&config_dir).await?;
    
    // Handle existing pm.bash file conflict
    if bash_file_path.exists() {
        let existing_content = fs::read_to_string(&bash_file_path).await?;
        if !existing_content.contains("# Generated by PM v") {
            // User-created file, ask for confirmation
            let should_overwrite = Confirm::new("Existing pm.bash file found. Overwrite?")
                .with_default(false)
                .prompt()?;
            
            if !should_overwrite {
                println!("❌ Bash integration setup cancelled");
                return Ok(());
            }
            
            // Backup existing file
            let backup_path = bash_file_path.with_extension("bash.backup");
            fs::copy(&bash_file_path, &backup_path).await?;
            println!("💾 Backed up existing file to: {}", backup_path.display());
        }
    }
    
    // Create the Bash function file
    let bash_content = create_bash_function_content();
    fs::write(&bash_file_path, bash_content).await?;
    
    // Add source line to .bashrc if it doesn't exist
    let source_line = "source ~/.config/pm/pm.bash";
    let mut needs_source_line = true;
    
    if bashrc_path.exists() {
        let bashrc_content = fs::read_to_string(&bashrc_path).await?;
        if bashrc_content.contains(source_line) || bashrc_content.contains(". ~/.config/pm/pm.bash") {
            needs_source_line = false;
        }
    }
    
    if needs_source_line {
        let source_comment = "\n# PM (Project Manager) shell integration\n";
        let source_content = format!("{}{}\n", source_comment, source_line);
        
        if bashrc_path.exists() {
            // Append to existing .bashrc
            let mut existing_content = fs::read_to_string(&bashrc_path).await?;
            existing_content.push_str(&source_content);
            fs::write(&bashrc_path, existing_content).await?;
        } else {
            // Create new .bashrc
            fs::write(&bashrc_path, source_content).await?;
        }
        
        println!("📝 Added source line to .bashrc");
    }
    
    println!("🐚 Bash shell integration installed successfully");
    println!("   Function file: {}", bash_file_path.display());
    println!("   Sourced from: {}", bashrc_path.display());
    println!("   Usage: pm sw <project> will now change your shell directory");
    
    Ok(())
}